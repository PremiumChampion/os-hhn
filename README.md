<!--

author:   Andreas Heil
email:    andreas.heil@hs-heilbronn.de
version:  0.1
language: de
narrator: DE German Male

comment:  

-->

[![LiaScript](https://raw.githubusercontent.com/LiaScript/LiaScript/master/badges/course.svg)](https://LiaScript.github.io/course/?https://github.com/aheil/os) 


# Betriebssysteme

Dieser Kurs ist Teil des Bachelor Studiengangs Software Engineering (SEB) und an der Hochschule Heilbronn.

Dies ist das Repository der Kursinformationen. Diese Seiten sind als [interaktiver Kurs verfügbar](https://liascript.github.io/course/?https://github.com/aheil/os) verfügbar.

Die Vorlesung Betriebssysteme (262007) wird von mir sowohl im Sommer- als auch dem Wintersemester im Kurs SEB2 angeboten. Die Vorlesungssprache ist Deutsch.

Die Veranstaltung basiert dabei auf dem Buch [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/) von Rezi H. und Andrea C. Arpaci-Dussseau.

Die Vorlesung wird dabei von mir um praktische Programmübungen ergänzt.

Veranstaltungsbegleitend empfehle ich die Übungsaufgaben aus dem Buch zu bearbeiten.

Das Buch ist als [freies PDF Buch]((http://pages.cs.wisc.edu/~remzi/OSTEP/)) erhältlich. Zusätzlich finden Sie Print-Exemplare in der Bibliothek bzw. in meinem Semesterapparat am Campus Sontheim.

Für Student:innen in meinem Kurs gibt es in jedem Semester ein [ILIAS Raum](https://ilias.hs-heilbronn.de/goto.php?target=crs_360705&client_id=iliashhn) mit Forum.

## Kursübersicht

**Dozent**

Prof. Andreas Heil

**Kursnummer**

262007 (SEB/SPO4)

**Level**

Grundstudium Bachelor

**Semesterwochenstunden/ECTS**

2/3

**Workload**

- 30h Kontaktstunden/Lerneinheiten
- 90h Selbststudium

**Kurszeiten** 

* 1 Vorlesungseinheit / Woche, 90 Min. / Einheit

Die genauen Veranstaltungszeiten entnehmen Sie bitte dem aktuellen [Stundenplan](https://splan.hs-heilbronn.de/). 

**Voraussetzungen**

Grundlegende Programmierkenntnisse als auch ein grundlegendes Verständnis für das Themengebiet der Informatik sind hilfreich.  

Sie sollten daher die Veranstaltung *261703 Interaktive Programme* als auch *261701 Grundlagen der Informatik* besucht und erfolgreich bestanden haben. 


**Beschreibung**

Die Studierenden kennen Aufgaben, Architektur, Komponenten und Funktionsweise sowie Klassifikationen von klassischen und modernen Betriebssystemen und haben grundlegende praktische Erfahrung mit unterschiedlichen aktuellen Betriebssystemen.

- Sie wissen, wie Prozesse oder Threads beschrieben und
kontrolliert werden können.
- Sie sind in der Lage mit Nebenläufigkeit in eigenen
Anwendungen umzugehen und die bekannten Synchronisationsmöglichkeiten sowie Verfahren zur Vermeidung, Umgehung oder Auflösung von Deadlocks korrekt einzusetzen.
- Die Studierenden kennen die wichtigsten Verfahren und Strategien des Speichermanagements sowie unterschiedliche
Scheduling-Methoden, und sie sind in der Lage, diese in eigenen Anwendungen vorteilhaft einzusetzen.
• Sie können die Eignung verschiedener Betriebssysteme oder Betriebssystemkonzepte für neue Anwendungen, Systemanforderungen oder Rechnerarchitekturen einschätzen.

**Vorlesung**

Jede Vorlesung behandelt ein spezielles Thema. 

Die Veranstaltung basiert dabei auf dem Buch Operating Systems: Three Easy Pieces von Rezi H. und Andrea C. Arpaci-Dussseau.

Veranstaltungsbegleitend empfehle ich die Übungsaufgaben aus dem Buch zu bearbeiten.

**Klausur**

Nach der Vorlesung findet im Prüfungszeitraum eine abschließende Klausur statt. Die Klausur muss mit mindestens einer 4.0 bestanden werden, um den Kurs insgesamt zu bestehen.  

Die Dauer der Klausur beträgt 90 Minuten. 

Das Klausurergebnis geht dabei mit insgesamt 70% in die Bewertung der Gesamtnote ein.

**Hausaufgaben**

Es gibt nicht bewertete Übungen bzw. Hausaufgaben zu jedem Buchkapitel. Ich empfehle die Aufgaben in kleineren Lerngruppen zu bearbeiten und die Themen so aus der Vorlesung zu vertiefen.

Zusätzlich gibt es zu manchen Vorlesungseinheiten Tutorials oder Übungen, die optimalerweise im Selbststudium erarbeitet werden.

Insgesamt gibt es drei C Programmierübungen, die von Ihnen in einer kleinen Gruppe bearbeitet werden. 

Die Gruppengrößen sind abhängig von der jeweiligen Kursgröße (2er- bis 4er-Gruppen). Die Gruppen bleiben bis zum Ende des Vorlesungszeitraums für alle Abgaben bestehen. Die Kurse werden nach der ersten Vorlesungseinheit zufällig festgelegt und bekanntgegeben.
Die Programmieraufgaben werden durch die Team-Mitglieder in GitLab eingecheckt und mit dem hochschuleigenen Commit-System eingereicht. 
Die Programmieraufgaben werden zu einer gegebenen Deadline eingereicht. Nachfristen werden nicht gewährt. Einreichungen auf anderem Weg als der oben beschriebene, werden nicht gewertet.

Die Ergebnisse der Programmierübungen gehen mit insgesamt 30% in die Gesamtnote ein.

**Abgaben**

Sämtliche Abgaben erfolgen über das fakultätsinterne Commit-System unter [https://commit.it.hs-heilbronn.de](https://commit.it.hs-heilbronn.de).
Das Commit-System ist nur aus dem Hochschulnetz bzw. über VPN erreichbar.

* Link zum Commit-System: [https://commit.it.hs-heilbronn.de](https://commit.it.hs-heilbronn.de) (nur im Hochschulnetz oder via VPN)
* Link zu GitLab: [https://gitlab.it.hs-heilbronn.de](https://gitlab.it.hs-heilbronn.de)

Zur Abgabe ist es erforderlich, dass die Aufgaben zuvor im hochschuleigenen GitLab unter [https://gitlab.it.hs-heilbronn.de](https://gitlab.it.hs-heilbronn.de) eingecheckt werden. Zugänge zu dem System werden in den ersten drei Wochen des Semesters ausgegeben.


**Benotung**

Die Note ergibt sich aus insgesamt 100 Punkten: 

| Aktivitäten | Anteil an der Note |
| --- | --- | 
| Programmieraufgaben | 30% |
| Klausur | 70 % | 

Für das Bestehen des Kurses ist das Bestehen der Klausur mit mind. einer 4,0 erforderlich.

Durch Nichteinreichen der Programmieraufgaben (oder Ergebnisse schlechter 4,0) kann sich Ihre Gesamtnote verschlechtern.

Beispiel: Sie haben in der Klausur eine 4.0 erhalten und keine Programmieraufgaben eingereicht. So ergibt dies insgesamt eine Note schlechter als 4,0 wodurch der Kurs als nicht bestanden gewertet wird. 

Sollten Sie die Klausur nicht bestehen, werden Ihnen die Übungsaufgaben für das kommende Semester **nicht** angerechnet. Die Abgaben sind erneut einzureichen.

**Zusammenarbeit**

 Programmieraufgaben sind in der zugeteilten Gruppe zu bearbeiten. Bei Gruppenabgaben werden alle Team-Mitglieder gleichermaßen bewertet, außer mind. ein Team-Mitglied beschwert sich hinsichtlich der Bewertung. In diesem Fall findet anstelle dessen eine individuelle Bewertung statt.

Es wird empfohlen auch die Übungsaufgaben aus dem Buch in Gruppen zu erarbeiten und zu diskutieren. 
Lediglich bei den Tutorials empfiehlt es sich diese zunächst im Selbststudium zu erschließen, bevor diese in der Gruppe be- oder nachbearbeitet werden.

**Lizenz**

Sofern nicht anders angegeben, steht das gesamte Kursmaterial unter einer [Creative Commons Namensnennung 4.0 International Lizenz](https://creativecommons.org/licenses/by/4.0/). 

## Kalender 

| Einheit # | Datum | Thema |
| --- | --- | --- |
|  1 | 29.09.2022 | Einführung in Git |
|  2 | 06.10.2022 | N.N. | 
|  3 | 13.10.2022 | N.N. |
|  4 | 20.10.2022 | N.N. | 
|  5 | 27.10.2022 | N.N. | 
|  6 | 03.11.2022 | N.N. | 
|  7 | 10.11.2022 | N.N. | 
|  8 | 17.11.2022 | N.N. | 
|  - | 24.11.2022 | Entfällt (Fortbildung) | 
|  - | 01.12.2022 | Entfällt (Blockwoche SEB) |
| 09 | 08.12.2022 | N.N. | 
| 10 | 15.12.2022 | N.N. | 
| 11 | 22.12.2022 | N.N. | 
| - | 29.12.2022 | Vorlesungsfrei |
| - | 05.01.2023 | Vorlesungsfrei | 
| 12 | 12.01.2023 | N.N. |
| 13 | 19.01.2023 | N.N. | 

## Einführung in Git 

### Lernziele

- Hintergründe von Versionsverwaltung kennenlernen
- Git Grundlagen kennenlernen
- Verstehen warum Git Workflows hilfreich sind

### Was ist Versionsverwaltung?

Es gibt alternative Bezeichnungen:

- Version Control Systems (VCS)
- Source Control Management (SCM)
- Revision Control Systems (RCS)

Software Projekte können schnell sehr groß und unübersichtlich werden.

- Hunderte bzw. tausende von Code-Dateien 

Sehr viele Entwickler können an einem Projekt beteiligt sein. 

- Versionsverwaltungen können helfen diese Komplexität in den Griff zu bekommen, indem die Änderungen an den Dateien über die Zeit hinweg protokolliert werden.

Historie: Selbst für einzelner Entwickler sinnvoll

- Änderungen über die Zeit sehen können
- "Zurückrollen" zu einem bestimmten Zeitpunkt 
- Was wäre die Alternative? Viele (sehr viele) Kopien einer Datei?

Mehrere Entwickler

- Sehen, wer welche Änderungen gemacht hat 
- Konflikte auflösen, wenn mehrere Entwickler Änderungen an der gleichen Datei/der gleichen Zeile durchgeführt haben 

Versionierung 

- Zustand eines Projekts wiederherstellen: zum Testen, für ein Release oder um die Einführung eines Fehlers zu finden 


### Was nutzen Entwickler?

![](img/survey_2015.png)

Quelle: https://insights.stackoverflow.com/survey/2015

![](img/survey_2018.png)

Quelle: https://insights.stackoverflow.com/survey/2018


### Woher kommt Git 

- Linux Community nutzte BitKeeper zur Verwaltung des Kernel Source Codes 
- Durch Lizenzänderung des Herstellers konnte BitKeeper nicht mehr genutzt werden
- Linus Torvalds wollte ein System, das ähnlich BitKeeper funktionierte, aber die Nachteile der anderen Systeme nicht mehr aufwies (z.B: lange Zeiten bei Branches durch Kopieren aller Dateien)
- Innerhalb weniger Tage wurde die erste Version von Git entwickelt:
- 3. April 2005 Ankündigung des Projektes 
- 7. April 2005 Self-Hosting des Projektes 
- 16. Juni 2005 Linux 2.6 Kernel wurde durch Git verwaltet 
 
### Git Grundlagen

- _Git Repository_: Vereinefacht, ein Verzeichnis, in dem die Dateien “überwacht” werden
- Metadaten (einschl. der Historie) werden in einem versteckten Unterverzeichnis (.git) verwaltet.
- Git ist eine verteilte Versionsverwaltung
- Keine Notwendigkeit eines zentralen Repositories 
- „Clonen“ bzw. „Forken“ eines Repositories legt eine vollständige Kopie an. Änderungen können dann in das ursprüngliche Repository zurückgeführt ( engl. merge) werden. 

### Git Dateistatus

![](img/git_dateistatus.png)

### Nützliches für den Einstieg

Lokale Änderungen anzeigen (engl. unstaged changes): `git diff [dateiname]`

Änderungshistorie: `git log` für Commits, `git –p log` für ein Preview

Checkout: Der Checkout einer früheren Version eines Repositories ersetzt alle Dateien mit dieser Version (time travel)

Branches: Alle Änderungen werden in dem Branch (dt. Zweig) gespeichert ohne den Hauptzweig (engl. master branch) zu beeinflussen („kaputt zu machen“)

Remote: “Entfernte“ Kopie eines Repositories (z.B: GitLab, GitHub) – Achtung: Selbst auf GitLab/GitHub ist nicht das zentrale 
Repository, sondern nur eine entfernte Kopie z.B. mit `git push`, `git pull`

Stash: Änderungen, die noch nicht "comitted" wurden, können mit `git stash` „zwischengespeichert“ und mit `git stash apply` wieder hergestellt werden

Fork: Server-seitiger Clone eines Repositories

### Git Workflows 

Trotzdem oder gerade wegen der verteilten Verwaltung kann so einiges schief gehen, daher gilt

![](img/git_one_does_not.jpg)

Verschieden Ansätze für Git Workflows

- Centralized Workflow
- Feature Branch Workflow
- Gitflow
- Fork & Merge
- Microsoft Git Branching Strategy  

### Weiterführendes Material 

- Git Command-line Tool: https://github.com/nschneid/git-command-overview
- GitHub: https://github.com/
- GitLab: https://about.gitlab.com/ 
- The case for Git in 2015: http://www.netinstructions.com/the-case-for-git/
- Pro Git Book: http://git-scm.com/book
- Udacity Kurs*): https://www.udacity.com/course/version-control-with-git--ud123
- Git User‘s Manual: http://schacon.github.com/git/user-manual.html
- Git – SVN Crashcourse: http://git.or.cz/course/svn.html
- Learn Git in Y minutes: https://learnxinyminutes.com/docs/git/ 
- Coding Blocks Podcast: Comparing Git Workflows: https://www.codingblocks.net/podcast/comparing-git-workflows/ 
- Gitflow Cheatsheet: https://danielkummer.github.io/git-flow-cheatsheet/ 
- Gitflow: https://nvie.com/posts/a-successful-git-branching-model/ 
- Atlassian‘s Gitflow Zusammenfassung:https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow
- Microsoft Recommendation: https://docs.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops&viewFallbackFrom=vsts
- Git Workflows: http://drincruz.github.io/slides/git-workflow-comparison/#/8 
- Git Spiel Oh my Git! : https://ohmygit.org/
- Auschecken von Commits: https://www.git-tower.com/learn/git/faq/git-checkout-commits/
- Wenn was schief geht: https://ohshitgit.com/ 

## Virtualisierung  

### Prozesse und Prozess API 

#### Lernziele und Kompetenzen

* **Verstehen** wie sich Prozesse zusammensetzen und Prozesse vom Betriebssystem verwaltet werden.
* **Verstehen** wie Prozesse im Betriebssystem gesteuert werden

#### Definition Prozess

**»Vereinfachte Definition«: Prozess**

Ein ausgeführtes bzw. laufendes Programm

![](img/os.01.taskmng1.png)



#### Programme

Was ist überhaupt ein Programm?

    * Besteht aus Code (Bits) und ggf. statischen Daten
    * Wartet auf der Festplatte und tut nichts
    * Erst durch die Ausführung wird ein Programm zum Prozess

Was benötigt ein Programm?

    * Benötigt zur Ausführung eine CPU 
    * Benötigt für den auszuführenden Code und die Daten Speicher 

#### Illusion

**Frage:** Wie kann die Illusion vieler CPUs geschaffen werden, wenn es nur eine (oder wenige) physikalische CPUs gibt?

Beispiel rechts: Windows Task Manager mit 262 Prozesse 

![](img/os.01.taskmng2.png)

#### Beispiel: Linux *top*

![](img/os.01.top.png)

#### Was ist Virtualisierung? 

* Wir geben jedem Prozess die CPU für eine kurze Zeitspanne 
* Dieses sog. »Timesharing« erzeugt eine Illusion mehrerer CPUs
* Konsequenz: Programm läuft langsamer, da die CPU »geteilt« wird 

**Das ist »sehr vereinfacht« Virtualisierung**

#### Was wird für Virtualisierung benötigt?

»Low Level Machinery« 

    * Methoden und Protokolle für die grundlegende Funktionalität 

»High Level Intelligence«

    * Irgendetwas Geschicktes zum Stoppen und Starten von Programmen 
    * Zusätzliches Regelwerk (engl. policies)
    * Regeln wie viele Prozesse auf einer CPU ausgeführt werden dürfen
    * Jemand oder etwas, der bzw. das steuert, welcher Prozess als nächstes ausgeführt wird

#### Abstraktion von Prozessen

Prozesse bestehen grundlegend aus

* Speicher, in dem die Programmanweisungen bzw. Instruktionen (engl. instructions) liegen
* Speicher, in dem die Daten geschrieben werden 
* Vom Prozess adressierbarer Speicher (engl. address space)
* Registern - Instruktionen lesen und schreiben in Register, dies ist notwendig für die Ausführung d. Prozesses

    **Diese Informationen können jederzeit »weggespeichert« und wiederhergestellt werden**

#### Spezielle Register, die benötigt werden

Program Counter (Abk. PC) oder auch Instruction Counter (Abk. IC)

* Hier steht die nächste Anweisung, die ausgeführt werden soll

* Stack Pointer, Frame Pointer, Funktionsparameter, lokale Variablen und Rücksprungadressen (engl. return address) - mehr dazu später

Register für I/O-Informationen

* Liste der Dateien, die der Prozess aktuell geöffnet hat  

#### Prozess-API 

Außerdem benötigen wir eine Programmierschnittstelle (engl. process api), die jedes Betriebssystem beinhalten muss (wird später noch weiter vertieft)

* `create`: Ausgewähltes Programm wird gestartet und ein neuer Prozess erzeugt 
* `destroy`: Falls sich ein Programm nicht von selbst beendet, ist dies sehr hilfreich
* `wait`: Durchaus sinnvoll zu warten, bis ein Prozess von selbst aufhört zu laufen
* `status`: Statusinformation von Prozessen abfragen 

Weitere Möglichkeiten sind je nach Betriebssystem unterschiedlich, z.B.:
`suspend` und `resume` um Prozesse anzuhalten und weiterlaufen zu lassen

#### Wie wird ein Prozess erzeugt?

1. Voraussetzung: Ein Programm muss in ausführbarer Form vorliegen (mehr dazu später)
2. Programm und statische Daten werden in den Adressraum des Prozesses geladen
    * »Früher« wurde das gesamte Programm in den Speicher geladen (engl. eagerly)
    * »Heute« wird nur der benötigte Programm-Code und die erforderlichen Daten geladen (engl. lazy)  

        Um dieses sog. »Lazy Loading« zu verstehen, werden wir uns später noch mit »Paging« und »Swapping« befassen müssen
3. Der sog. »Stack« bzw. »Runtime Stack« wird zugewiesen
    * C nutzt den Stack für lokale Variablen, Funktionsparameter und Rücksprungadressen
4. Das Betriebssystem füllt z.B. die Parameterlisten
    * Bei C sind dies `argc` und `argv`, so dass das Programm (hier die `main`-Funktion) auf die Werte zugreifen kann[^4]
    * Kennen Sie auch aus Java
5. Nun wird noch der Heap reserviert 
    * In C für dynamischen Speicherzuordnung via `malloc()` und `free()`
    * Exkurs: Memoryleaks baut man übrigens, indem man in C vergisst `free()` aufzurufen

![](img/os.01.processcreation.png)

6. Das Betriebssystem unterstütz nun den Prozess, indem es z.B. dem Prozess mehr Speicher gibt, wenn der Heap vergrößert werden muss 
7. Nun  werden noch Input/Output-Resourcen erzeugt (sie ahnen es, später mehr dazu)

    * Unter UNIX sind dies die drei sog. »File Descriptors« (https://sites.ualberta.ca/dept/chemeng/AIX-43/share/man/info/C/a_doc_lib/aixuser/usrosdev/std_input_output.htm)
        * Standard Input, 
        * Standard Output und 
        * Standard Error Output

#### Prozess Status

Was bedeuten eigentlich die Status...?

* Laufend
* Schlafend 
* Gestoppt
* Zombie

> Tasks shown as running should be more properly thought of as 'ready to run' -- their task_struct is simply represented on the Linux run-queue. Even without a true SMP machine, you may see numerous tasks in this state depending on top's delay interval and nice value.

Quelle: https://man7.org/linux/man-pages/man1/top.1.html

#### Prozessstatus & mögliche Statusübergänge


* **Running:** Prozess läuft auf einer CPU 
* **Ready:** Prozess könnte laufen, aber das OS hat entschieden, den Prozess noch nicht laufen zu lassen
* **Blocked:** Prozess hat eine Aktion ausgeführt, die erst abgeschlossen werden kann, wenn ein anderes Ereignis stattgefunden hat - typischerweise handelt es sich hierbei um eine I/O-Operation

    Ist ein Prozess geblockt, wartet das Betriebssystem auf die I/O-Operation, um dann den Prozess wieder in den Status *Ready* zu verschieben. 

 ![](img/os.01.status.png)

#### Ein kleines Problem 

Wer entscheidet eigentlich welcher Prozess als nächster gestartet wird?

Der sog. »Scheduler« trifft diese Entscheidung (später mehr dazu)

Bevor wir uns den Scheduler anschauen, müssen wir uns allerdings noch ein paar weitere Gedanken über Prozesse machen… 

#### Ein paar Gedanken zu Prozessen 

Wir benötigen
* Eine Datenstruktur für Prozesse 
* Eine Liste aller Prozesse
* Eine Liste aller blockierten Prozesse
* Eine Möglichkeit Register bei Stoppen wegzuspeichern und beim Anlaufen des Prozesses wieder zu laden (engl. context switch)

Und was passiert eigentlich, wenn ein Prozess beendet ist, aber noch nicht alles »aufgeräumt« wurde? 

In UNIX-Systemen haben solche Prozesse einen eigenen Status: **Zombie** 

#### Exkurs: Datenstruktur von xv6-Prozessen

Alle Informationen über einen Prozess stehen in einem Prozesskontrollblock (engl. process control block, kurz PCB) 

![](img/os.01.pcb.png)

#### Zusammenfassung

* Prozesse sind die grundlegende Abstraktion eines Programmes
* Zu jedem Zeitpunkt kann ein Prozess über seinen Status, den Speicherinhalt, seinen Adressraums, den Inhalt der CPU-Register (einschl. program counter und stack pointer) und den I/O-Informationen (d.h. geöffnete Dateien) beschrieben werden
* Die Prozess-API besteht aus Aufrufen, die in Zusammenhang mit Prozessen ausgeführt werden können, z.B. zum Erzeugen oder Beenden von Prozessen
* Unterschiedliche Ereignisse führen zu Statusänderungen im Prozess (z.B. der Aufruf einer blockierenden I/O-Operation)
* Eine Prozessliste enthält alle Informationen über die Prozesse auf einem System

#### Wiederholungsfragen Prozesse und Prozess-API 

##### Welche Status von Prozessen haben Sie kennen gelernt? 

- [[x]] Laufend
- [[ ]] Wartend
- [[x]] Schlafend
- [[x]] Gestoppt
- [[ ]] Vampir
- [[x]] Zombie

## Hausaufgaben

### Einheit 1 (Git)

- Udacity Kurs zum Thema Git: [https://www.udacity.com/course/version-control-with-git--ud123]https://www.udacity.com/course/version-control-with-git--ud123
- 1x in GitLab (https://git.it.hs-heilbronn.de) anmelden
- C-Crashkurs durcharbeiten: https://github.com/aheil/hhn-c

### Einheit 2 (Prozess API)

- Bearbeiten Sie die Übungsaufgaben zum Thema Process API aus dem OSTEP-Buch [https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf)
